package org.egov.malware.controller;

import lombok.extern.slf4j.Slf4j;
import org.egov.malware.model.*;
import org.egov.malware.repository.ScanResultRepository;
import org.egov.malware.service.ScanAuditService;
import org.egov.malware.service.ScanService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/malware-detection/v1")
@Slf4j
public class ScanController {

    private final ScanService scanService;
    private final ScanResultRepository scanResultRepository;
    private final ScanAuditService scanAuditService;

    @Autowired
    public ScanController(ScanService scanService,
                          ScanResultRepository scanResultRepository,
                          ScanAuditService scanAuditService) {
        this.scanService = scanService;
        this.scanResultRepository = scanResultRepository;
        this.scanAuditService = scanAuditService;
    }

    /**
     * Manual scan endpoint - for triggering scan on demand
     */
    @PostMapping("/scan")
    public ResponseEntity<ScanResult> scan(@RequestBody MalwareScanRequest request) {
        log.info("Manual scan request received for fileStoreId: {}", request.getFileStoreId());

        ScanResult result = scanService.scan(request);

        HttpStatus status = result.getStatus() == ScanStatus.CLEAN ? HttpStatus.OK : HttpStatus.OK;
        return new ResponseEntity<>(result, status);
    }

    /**
     * Get scan result by fileStoreId
     */
    @GetMapping("/result")
    public ResponseEntity<Object> getScanResult(
            @RequestParam String fileStoreId,
            @RequestParam String tenantId) {

        log.info("Get scan result for fileStoreId: {}, tenantId: {}", fileStoreId, tenantId);

        Optional<ScanResult> result = scanResultRepository.findByFileStoreId(fileStoreId, tenantId);

        if (result.isPresent()) {
            return ResponseEntity.ok(result.get());
        } else {
            Map<String, Object> response = new HashMap<>();
            response.put("fileStoreId", fileStoreId);
            response.put("tenantId", tenantId);
            response.put("status", "NOT_SCANNED");
            response.put("message", "No scan result found for this file");
            return ResponseEntity.ok(response);
        }
    }

    /**
     * Get scan results by status
     */
    @GetMapping("/results/status/{status}")
    public ResponseEntity<List<ScanResult>> getScanResultsByStatus(
            @PathVariable String status,
            @RequestParam String tenantId,
            @RequestParam(defaultValue = "100") int limit) {

        log.info("Get scan results by status: {}, tenantId: {}", status, tenantId);

        try {
            ScanStatus scanStatus = ScanStatus.valueOf(status.toUpperCase());
            List<ScanResult> results = scanResultRepository.findByStatus(scanStatus, tenantId, limit);
            return ResponseEntity.ok(results);
        } catch (IllegalArgumentException e) {
            log.error("Invalid status: {}", status);
            return ResponseEntity.badRequest().build();
        }
    }

    /**
     * Get scan results by tenant
     */
    @GetMapping("/results")
    public ResponseEntity<List<ScanResult>> getScanResults(
            @RequestParam String tenantId,
            @RequestParam(defaultValue = "100") int limit,
            @RequestParam(defaultValue = "0") int offset) {

        log.info("Get scan results for tenantId: {}", tenantId);

        List<ScanResult> results = scanResultRepository.findByTenant(tenantId, limit, offset);
        return ResponseEntity.ok(results);
    }

    /**
     * Get infected files count
     */
    @GetMapping("/stats")
    public ResponseEntity<Map<String, Object>> getStats(@RequestParam String tenantId) {
        log.info("Get stats for tenantId: {}", tenantId);

        Map<String, Object> stats = new HashMap<>();

        List<ScanResult> cleanFiles = scanResultRepository.findByStatus(ScanStatus.CLEAN, tenantId, Integer.MAX_VALUE);
        List<ScanResult> infectedFiles = scanResultRepository.findByStatus(ScanStatus.INFECTED, tenantId, Integer.MAX_VALUE);
        List<ScanResult> quarantinedFiles = scanResultRepository.findByStatus(ScanStatus.QUARANTINED, tenantId, Integer.MAX_VALUE);
        List<ScanResult> errorFiles = scanResultRepository.findByStatus(ScanStatus.ERROR, tenantId, Integer.MAX_VALUE);

        stats.put("tenantId", tenantId);
        stats.put("cleanCount", cleanFiles.size());
        stats.put("infectedCount", infectedFiles.size());
        stats.put("quarantinedCount", quarantinedFiles.size());
        stats.put("errorCount", errorFiles.size());
        stats.put("totalScanned", cleanFiles.size() + infectedFiles.size() + quarantinedFiles.size() + errorFiles.size());
        stats.put("timestamp", System.currentTimeMillis());

        return ResponseEntity.ok(stats);
    }

    // ==================== AUDIT TRAIL ENDPOINTS ====================

    /**
     * Get audit trail for a specific file by fileStoreId
     */
    @GetMapping("/audit/file")
    public ResponseEntity<List<ScanAudit>> getAuditByFileStoreId(
            @RequestParam String fileStoreId,
            @RequestParam String tenantId) {

        log.info("Get audit trail for fileStoreId: {}, tenantId: {}", fileStoreId, tenantId);

        List<ScanAudit> audits = scanAuditService.getAuditTrailByFileStoreId(fileStoreId, tenantId);
        return ResponseEntity.ok(audits);
    }

    /**
     * Get audit trail for a scan result by scanResultId
     */
    @GetMapping("/audit/scan/{scanResultId}")
    public ResponseEntity<List<ScanAudit>> getAuditByScanResultId(
            @PathVariable String scanResultId) {

        log.info("Get audit trail for scanResultId: {}", scanResultId);

        List<ScanAudit> audits = scanAuditService.getAuditTrail(scanResultId);
        return ResponseEntity.ok(audits);
    }

    /**
     * Get recent audit entries for a tenant
     */
    @GetMapping("/audit")
    public ResponseEntity<List<ScanAudit>> getRecentAudits(
            @RequestParam String tenantId,
            @RequestParam(defaultValue = "100") int limit,
            @RequestParam(defaultValue = "0") int offset) {

        log.info("Get recent audits for tenantId: {}, limit: {}, offset: {}", tenantId, limit, offset);

        List<ScanAudit> audits = scanAuditService.getRecentAudits(tenantId, limit, offset);
        return ResponseEntity.ok(audits);
    }

    /**
     * Get audit entries by action type
     */
    @GetMapping("/audit/action/{action}")
    public ResponseEntity<Object> getAuditsByAction(
            @PathVariable String action,
            @RequestParam String tenantId,
            @RequestParam(defaultValue = "100") int limit) {

        log.info("Get audits by action: {}, tenantId: {}", action, tenantId);

        try {
            AuditAction auditAction = AuditAction.valueOf(action.toUpperCase());
            List<ScanAudit> audits = scanAuditService.getAuditsByAction(auditAction, tenantId, limit);
            return ResponseEntity.ok(audits);
        } catch (IllegalArgumentException e) {
            Map<String, Object> error = new HashMap<>();
            error.put("error", "Invalid action type");
            error.put("validActions", AuditAction.values());
            return ResponseEntity.badRequest().body(error);
        }
    }

    /**
     * Get audit entries by time range
     */
    @GetMapping("/audit/timerange")
    public ResponseEntity<List<ScanAudit>> getAuditsByTimeRange(
            @RequestParam String tenantId,
            @RequestParam long startTime,
            @RequestParam long endTime) {

        log.info("Get audits by time range for tenantId: {}, from: {} to: {}", tenantId, startTime, endTime);

        List<ScanAudit> audits = scanAuditService.getAuditsByTimeRange(tenantId, startTime, endTime);
        return ResponseEntity.ok(audits);
    }
}
