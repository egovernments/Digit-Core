package org.egov.malware.repository;

import lombok.extern.slf4j.Slf4j;
import org.egov.malware.model.AuditAction;
import org.egov.malware.model.ScanAudit;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

/**
 * Repository for malware scan audit operations.
 */
@Repository
@Slf4j
public class ScanAuditRepository {

    private final JdbcTemplate jdbcTemplate;

    private static final String INSERT_QUERY = """
            INSERT INTO eg_malware_scan_audit (
                scan_result_id, filestore_id, tenant_id, action, action_details, action_time, action_by
            ) VALUES (?, ?, ?, ?, ?, ?, ?)
            """;

    private static final String SELECT_BY_SCAN_RESULT_ID = """
            SELECT * FROM eg_malware_scan_audit
            WHERE scan_result_id = ?
            ORDER BY action_time ASC
            """;

    private static final String SELECT_BY_FILESTORE_ID = """
            SELECT * FROM eg_malware_scan_audit
            WHERE filestore_id = ? AND tenant_id = ?
            ORDER BY action_time ASC
            """;

    private static final String SELECT_BY_TENANT = """
            SELECT * FROM eg_malware_scan_audit
            WHERE tenant_id = ?
            ORDER BY action_time DESC
            LIMIT ? OFFSET ?
            """;

    private static final String SELECT_BY_ACTION = """
            SELECT * FROM eg_malware_scan_audit
            WHERE action = ? AND tenant_id = ?
            ORDER BY action_time DESC
            LIMIT ?
            """;

    private static final String SELECT_BY_TIME_RANGE = """
            SELECT * FROM eg_malware_scan_audit
            WHERE tenant_id = ? AND action_time BETWEEN ? AND ?
            ORDER BY action_time DESC
            """;

    @Autowired
    public ScanAuditRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    /**
     * Saves a new audit entry.
     */
    public void save(ScanAudit audit) {
        log.debug("Saving audit entry for fileStoreId: {}, action: {}",
                audit.getFileStoreId(), audit.getAction());

        jdbcTemplate.update(INSERT_QUERY,
                audit.getScanResultId(),
                audit.getFileStoreId(),
                audit.getTenantId(),
                audit.getAction().name(),
                audit.getActionDetails(),
                audit.getActionTime(),
                audit.getActionBy()
        );

        log.debug("Audit entry saved successfully");
    }

    /**
     * Finds all audit entries for a scan result.
     */
    public List<ScanAudit> findByScanResultId(String scanResultId) {
        log.debug("Finding audit entries for scanResultId: {}", scanResultId);
        return jdbcTemplate.query(SELECT_BY_SCAN_RESULT_ID, new ScanAuditRowMapper(), scanResultId);
    }

    /**
     * Finds all audit entries for a filestore ID.
     */
    public List<ScanAudit> findByFileStoreId(String fileStoreId, String tenantId) {
        log.debug("Finding audit entries for fileStoreId: {}, tenantId: {}", fileStoreId, tenantId);
        return jdbcTemplate.query(SELECT_BY_FILESTORE_ID, new ScanAuditRowMapper(), fileStoreId, tenantId);
    }

    /**
     * Finds audit entries by tenant with pagination.
     */
    public List<ScanAudit> findByTenant(String tenantId, int limit, int offset) {
        log.debug("Finding audit entries for tenantId: {}", tenantId);
        return jdbcTemplate.query(SELECT_BY_TENANT, new ScanAuditRowMapper(), tenantId, limit, offset);
    }

    /**
     * Finds audit entries by action type.
     */
    public List<ScanAudit> findByAction(AuditAction action, String tenantId, int limit) {
        log.debug("Finding audit entries for action: {}, tenantId: {}", action, tenantId);
        return jdbcTemplate.query(SELECT_BY_ACTION, new ScanAuditRowMapper(), action.name(), tenantId, limit);
    }

    /**
     * Finds audit entries within a time range.
     */
    public List<ScanAudit> findByTimeRange(String tenantId, long startTime, long endTime) {
        log.debug("Finding audit entries for tenantId: {} between {} and {}", tenantId, startTime, endTime);
        return jdbcTemplate.query(SELECT_BY_TIME_RANGE, new ScanAuditRowMapper(), tenantId, startTime, endTime);
    }

    /**
     * Row mapper for ScanAudit.
     */
    private static class ScanAuditRowMapper implements RowMapper<ScanAudit> {
        @Override
        public ScanAudit mapRow(ResultSet rs, int rowNum) throws SQLException {
            return ScanAudit.builder()
                    .id(rs.getLong("id"))
                    .scanResultId(rs.getString("scan_result_id"))
                    .fileStoreId(rs.getString("filestore_id"))
                    .tenantId(rs.getString("tenant_id"))
                    .action(AuditAction.valueOf(rs.getString("action")))
                    .actionDetails(rs.getString("action_details"))
                    .actionTime(rs.getLong("action_time"))
                    .actionBy(rs.getString("action_by"))
                    .build();
        }
    }
}
