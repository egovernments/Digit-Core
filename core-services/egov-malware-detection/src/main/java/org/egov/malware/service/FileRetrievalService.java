package org.egov.malware.service;

import io.minio.GetObjectArgs;
import io.minio.MinioClient;
import io.minio.StatObjectArgs;
import io.minio.StatObjectResponse;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.io.IOUtils;
import org.egov.malware.config.MalwareDetectionConfig;
import org.egov.malware.model.FileInfo;
import org.egov.malware.model.MalwareScanRequest;
import org.egov.tracer.model.CustomException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

@Service
@Slf4j
public class FileRetrievalService {

    private final MinioClient minioClient;
    private final MalwareDetectionConfig config;

    @Autowired
    public FileRetrievalService(MinioClient minioClient, MalwareDetectionConfig config) {
        this.minioClient = minioClient;
        this.config = config;
    }

    private static final String MINIO_SOURCE = "minio";
    private static final String AZURE_SOURCE = "AzureBlobStorage";

    /**
     * Fetches a file from storage based on the scan request.
     *
     * @param scanRequest The malware scan request containing file location info
     * @return FileInfo containing the file content and metadata
     */
    public FileInfo fetchFile(MalwareScanRequest scanRequest) {
        log.info("[FILE-RETRIEVAL] ========== FETCHING FILE FROM STORAGE ==========");
        log.info("[FILE-RETRIEVAL] fileStoreId: {}", scanRequest.getFileStoreId());
        log.info("[FILE-RETRIEVAL] tenantId: {}", scanRequest.getTenantId());
        log.info("[FILE-RETRIEVAL] fileName: {}", scanRequest.getFileName());
        log.info("[FILE-RETRIEVAL] fileSource: {}", scanRequest.getFileSource());
        log.info("[FILE-RETRIEVAL] filePath: {}", scanRequest.getFilePath());

        // Validate storage backend - currently only MinIO/S3 is supported
        log.info("[FILE-RETRIEVAL] Validating file source...");
        validateFileSource(scanRequest.getFileSource(), scanRequest.getFileStoreId());

        try {
            String objectPath = getObjectPath(scanRequest);
            String bucketName = config.getMinioBucketName();

            log.info("[FILE-RETRIEVAL] MinIO bucket: {}", bucketName);
            log.info("[FILE-RETRIEVAL] Object path: {}", objectPath);
            log.info("[FILE-RETRIEVAL] MinIO URL: {}", config.getMinioUrl());

            // Get file metadata first
            log.info("[FILE-RETRIEVAL] Getting file metadata from MinIO...");
            StatObjectResponse statResponse = minioClient.statObject(
                    StatObjectArgs.builder()
                            .bucket(bucketName)
                            .object(objectPath)
                            .build()
            );
            log.info("[FILE-RETRIEVAL] File metadata retrieved - size: {} bytes, contentType: {}",
                    statResponse.size(), statResponse.contentType());

            // Get file content as stream
            log.info("[FILE-RETRIEVAL] Downloading file content from MinIO...");
            InputStream inputStream = minioClient.getObject(
                    GetObjectArgs.builder()
                            .bucket(bucketName)
                            .object(objectPath)
                            .build()
            );

            // Read content into byte array for scanning
            byte[] content = IOUtils.toByteArray(inputStream);
            inputStream.close();
            log.info("[FILE-RETRIEVAL] File downloaded - {} bytes read", content.length);

            // Calculate SHA-256 hash
            log.info("[FILE-RETRIEVAL] Calculating SHA-256 hash...");
            String fileHash = calculateSHA256Hash(content);
            log.info("[FILE-RETRIEVAL] Hash calculated: {}", fileHash);

            FileInfo fileInfo = FileInfo.builder()
                    .fileStoreId(scanRequest.getFileStoreId())
                    .tenantId(scanRequest.getTenantId())
                    .fileName(scanRequest.getFileName())
                    .filePath(objectPath)
                    .contentType(statResponse.contentType())
                    .fileSize(statResponse.size())
                    .fileHash(fileHash)
                    .fileSource(scanRequest.getFileSource())
                    .content(content)
                    .build();

            log.info("[FILE-RETRIEVAL] ========== FILE FETCH SUCCESS ==========");
            log.info("[FILE-RETRIEVAL] fileStoreId: {}", fileInfo.getFileStoreId());
            log.info("[FILE-RETRIEVAL] fileSize: {} bytes", fileInfo.getFileSize());
            log.info("[FILE-RETRIEVAL] fileHash: {}", fileInfo.getFileHash());
            log.info("[FILE-RETRIEVAL] contentType: {}", fileInfo.getContentType());
            log.info("[FILE-RETRIEVAL] ========================================");

            return fileInfo;

        } catch (Exception e) {
            log.error("[FILE-RETRIEVAL] ========== FILE FETCH FAILED ==========");
            log.error("[FILE-RETRIEVAL] fileStoreId: {}", scanRequest.getFileStoreId());
            log.error("[FILE-RETRIEVAL] Error type: {}", e.getClass().getSimpleName());
            log.error("[FILE-RETRIEVAL] Error message: {}", e.getMessage());
            log.error("[FILE-RETRIEVAL] Stack trace:", e);
            log.error("[FILE-RETRIEVAL] ========================================");

            throw new CustomException("FILE_RETRIEVAL_ERROR",
                    "Failed to retrieve file from storage: " + e.getMessage());
        }
    }

    /**
     * Validates that the file source is supported.
     * Currently only MinIO/S3 storage is supported.
     *
     * @param fileSource   The storage backend identifier
     * @param fileStoreId  The file store ID for logging
     */
    private void validateFileSource(String fileSource, String fileStoreId) {
        if (fileSource == null || fileSource.isEmpty()) {
            log.warn("File source not specified for fileStoreId: {}, assuming MinIO/S3", fileStoreId);
            return;
        }

        if (AZURE_SOURCE.equals(fileSource)) {
            log.error("Azure Blob Storage is not supported by malware detection service - fileStoreId: {}", fileStoreId);
            throw new CustomException("UNSUPPORTED_STORAGE",
                    "Azure Blob Storage is not currently supported for malware scanning. Only MinIO/S3 storage is supported.");
        }

        if (!MINIO_SOURCE.equals(fileSource)) {
            log.warn("Unknown file source '{}' for fileStoreId: {}, attempting MinIO/S3 retrieval", fileSource, fileStoreId);
        }
    }

    private String getObjectPath(MalwareScanRequest scanRequest) {
        String path = null;

        // If filePath is provided, use it; otherwise use fileName
        if (scanRequest.getFilePath() != null && !scanRequest.getFilePath().isEmpty()) {
            path = scanRequest.getFilePath();
        } else {
            path = scanRequest.getFileName();
        }

        if (path == null || path.isEmpty()) {
            log.error("[FILE-RETRIEVAL] No file path available for fileStoreId: {}", scanRequest.getFileStoreId());
            return path;
        }

        // The filestore stores fileName with bucket prefix (e.g., "egov-rainmaker/mz/module/...")
        // But MinIO expects the object path WITHOUT the bucket prefix
        // So we need to strip the bucket name if it's included as a prefix
        String bucketName = config.getMinioBucketName();
        String bucketPrefix = bucketName + "/";

        if (path.startsWith(bucketPrefix)) {
            String strippedPath = path.substring(bucketPrefix.length());
            log.info("[FILE-RETRIEVAL] Stripped bucket prefix '{}' from path", bucketPrefix);
            log.info("[FILE-RETRIEVAL] Original path: {}", path);
            log.info("[FILE-RETRIEVAL] Stripped path: {}", strippedPath);
            return strippedPath;
        }

        log.info("[FILE-RETRIEVAL] Using path as-is (no bucket prefix found): {}", path);
        return path;
    }

    public String calculateSHA256Hash(byte[] content) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = digest.digest(content);
            return bytesToHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            log.error("SHA-256 algorithm not available", e);
            throw new CustomException("HASH_CALCULATION_ERROR", "Failed to calculate file hash");
        }
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xff & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }

    public byte[] getFileContent(String fileStoreId, String tenantId, String filePath) {
        log.debug("Getting file content for fileStoreId: {}", fileStoreId);
        try {
            InputStream inputStream = minioClient.getObject(
                    GetObjectArgs.builder()
                            .bucket(config.getMinioBucketName())
                            .object(filePath)
                            .build()
            );
            byte[] content = IOUtils.toByteArray(inputStream);
            inputStream.close();
            return content;
        } catch (Exception e) {
            log.error("Error getting file content - fileStoreId: {}", fileStoreId, e);
            throw new CustomException("FILE_CONTENT_ERROR", "Failed to get file content: " + e.getMessage());
        }
    }
}
