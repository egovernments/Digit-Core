package org.egov.malware.service;

import lombok.extern.slf4j.Slf4j;
import org.egov.malware.config.MalwareDetectionConfig;
import org.egov.malware.model.ClamAVResponse;
import org.egov.malware.model.FileInfo;
import org.egov.tracer.model.CustomException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.*;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.charset.StandardCharsets;

@Service
@Slf4j
public class ClamAVService {

    private static final String INSTREAM_COMMAND = "zINSTREAM\0";
    private static final String RESPONSE_OK = "OK";
    private static final String RESPONSE_FOUND = "FOUND";
    private static final String RESPONSE_ERROR = "ERROR";
    private static final String SCAN_ENGINE = "ClamAV";

    private final MalwareDetectionConfig config;

    @Autowired
    public ClamAVService(MalwareDetectionConfig config) {
        this.config = config;
    }

    public ClamAVResponse scanFile(FileInfo fileInfo) {
        log.info("[CLAMAV] ========== STARTING CLAMAV SCAN ==========");
        log.info("[CLAMAV] fileStoreId: {}", fileInfo.getFileStoreId());
        log.info("[CLAMAV] fileName: {}", fileInfo.getFileName());
        log.info("[CLAMAV] fileSize: {} bytes", fileInfo.getFileSize());
        log.info("[CLAMAV] fileHash: {}", fileInfo.getFileHash());
        log.info("[CLAMAV] ClamAV host: {}:{}", config.getClamavHost(), config.getClamavPort());

        long startTime = System.currentTimeMillis();

        try (Socket socket = createSocket();
             OutputStream outputStream = new BufferedOutputStream(socket.getOutputStream());
             InputStream inputStream = socket.getInputStream()) {

            log.info("[CLAMAV] Connected to ClamAV daemon successfully");

            // Step 1: Send INSTREAM command
            log.info("[CLAMAV] Step 1: Sending INSTREAM command...");
            outputStream.write(INSTREAM_COMMAND.getBytes(StandardCharsets.US_ASCII));
            outputStream.flush();
            log.info("[CLAMAV] Step 1: INSTREAM command sent");

            // Step 2: Stream file content in chunks
            byte[] content = fileInfo.getContent();
            int chunkSize = config.getClamavChunkSize();
            int offset = 0;
            int chunkCount = 0;

            log.info("[CLAMAV] Step 2: Streaming {} bytes to ClamAV in chunks of {} bytes",
                    content.length, chunkSize);

            while (offset < content.length) {
                int remaining = content.length - offset;
                int currentChunkSize = Math.min(chunkSize, remaining);

                // Send chunk size as 4-byte big-endian integer
                byte[] sizeBytes = intToByteArray(currentChunkSize);
                outputStream.write(sizeBytes);

                // Send chunk data
                outputStream.write(content, offset, currentChunkSize);
                outputStream.flush();

                offset += currentChunkSize;
                chunkCount++;
            }
            log.info("[CLAMAV] Step 2: Streamed {} chunks to ClamAV", chunkCount);

            // Step 3: Send EOF marker (4 zero bytes)
            log.info("[CLAMAV] Step 3: Sending EOF marker...");
            outputStream.write(intToByteArray(0));
            outputStream.flush();
            log.info("[CLAMAV] Step 3: EOF marker sent");

            // Step 4: Read response
            log.info("[CLAMAV] Step 4: Waiting for ClamAV response...");
            String response = readResponse(inputStream);
            long scanDuration = System.currentTimeMillis() - startTime;

            log.info("[CLAMAV] Step 4: Received response in {}ms", scanDuration);
            log.info("[CLAMAV] Raw response: '{}'", response);

            // Step 5: Parse response
            log.info("[CLAMAV] Step 5: Parsing response...");
            ClamAVResponse clamResponse = parseResponse(response, scanDuration);

            log.info("[CLAMAV] ========== CLAMAV SCAN RESULT ==========");
            log.info("[CLAMAV] isClean: {}", clamResponse.isClean());
            log.info("[CLAMAV] virusName: {}", clamResponse.getVirusName());
            log.info("[CLAMAV] errorMessage: {}", clamResponse.getErrorMessage());
            log.info("[CLAMAV] scanDurationMs: {}", clamResponse.getScanDurationMs());
            log.info("[CLAMAV] ===========================================");

            return clamResponse;

        } catch (IOException e) {
            long scanDuration = System.currentTimeMillis() - startTime;
            log.error("[CLAMAV] ========== CLAMAV CONNECTION ERROR ==========");
            log.error("[CLAMAV] Failed to connect or communicate with ClamAV");
            log.error("[CLAMAV] Host: {}:{}", config.getClamavHost(), config.getClamavPort());
            log.error("[CLAMAV] Error: {}", e.getMessage());
            log.error("[CLAMAV] Stack trace:", e);
            log.error("[CLAMAV] ================================================");

            return ClamAVResponse.builder()
                    .clean(false)
                    .errorMessage("ClamAV connection error: " + e.getMessage())
                    .scanDurationMs(scanDuration)
                    .build();
        }
    }

    private Socket createSocket() throws IOException {
        log.debug("Connecting to ClamAV at {}:{}", config.getClamavHost(), config.getClamavPort());
        Socket socket = new Socket(config.getClamavHost(), config.getClamavPort());
        socket.setSoTimeout(config.getClamavTimeout());
        return socket;
    }

    private byte[] intToByteArray(int value) {
        return ByteBuffer.allocate(4)
                .order(ByteOrder.BIG_ENDIAN)
                .putInt(value)
                .array();
    }

    private String readResponse(InputStream inputStream) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int bytesRead;

        while ((bytesRead = inputStream.read(buffer)) != -1) {
            baos.write(buffer, 0, bytesRead);
            // Check if we've received the complete response (ends with newline or null)
            String currentResponse = baos.toString(StandardCharsets.US_ASCII);
            if (currentResponse.contains("\n") || currentResponse.contains("\0")) {
                break;
            }
        }

        String response = baos.toString(StandardCharsets.US_ASCII).trim();
        // Remove null terminator if present
        if (response.endsWith("\0")) {
            response = response.substring(0, response.length() - 1);
        }
        return response;
    }

    private ClamAVResponse parseResponse(String response, Long scanDuration) {
        if (response == null || response.isEmpty()) {
            return ClamAVResponse.error("Empty response from ClamAV");
        }

        // Response format: "stream: OK" or "stream: VirusName FOUND" or "stream: ERROR message"
        String normalizedResponse = response.trim();

        if (normalizedResponse.contains(RESPONSE_OK)) {
            // File is clean: "stream: OK"
            return ClamAVResponse.clean(response, scanDuration);

        } else if (normalizedResponse.contains(RESPONSE_FOUND)) {
            // File is infected: "stream: VirusName FOUND"
            String virusName = extractVirusName(normalizedResponse);
            return ClamAVResponse.infected(virusName, response, scanDuration);

        } else if (normalizedResponse.contains(RESPONSE_ERROR)) {
            // Error occurred: "stream: ERROR message"
            String errorMessage = extractErrorMessage(normalizedResponse);
            return ClamAVResponse.builder()
                    .clean(false)
                    .errorMessage(errorMessage)
                    .rawResponse(response)
                    .scanDurationMs(scanDuration)
                    .build();

        } else {
            // Unknown response
            log.warn("Unknown ClamAV response format: {}", response);
            return ClamAVResponse.builder()
                    .clean(false)
                    .errorMessage("Unknown ClamAV response: " + response)
                    .rawResponse(response)
                    .scanDurationMs(scanDuration)
                    .build();
        }
    }

    private String extractVirusName(String response) {
        // Response format: "stream: VirusName FOUND"
        // Extract everything between "stream: " and " FOUND"
        try {
            String prefix = "stream:";
            int startIndex = response.indexOf(prefix);
            if (startIndex != -1) {
                startIndex += prefix.length();
            } else {
                startIndex = 0;
            }

            int endIndex = response.indexOf(RESPONSE_FOUND);
            if (endIndex != -1) {
                return response.substring(startIndex, endIndex).trim();
            }
        } catch (Exception e) {
            log.warn("Failed to extract virus name from response: {}", response);
        }
        return "Unknown Malware";
    }

    private String extractErrorMessage(String response) {
        // Response format: "stream: ERROR message"
        try {
            String prefix = RESPONSE_ERROR;
            int startIndex = response.indexOf(prefix);
            if (startIndex != -1) {
                return response.substring(startIndex + prefix.length()).trim();
            }
        } catch (Exception e) {
            log.warn("Failed to extract error message from response: {}", response);
        }
        return response;
    }

    public boolean isAvailable() {
        try (Socket socket = createSocket()) {
            // Send PING command
            OutputStream out = socket.getOutputStream();
            out.write("zPING\0".getBytes(StandardCharsets.US_ASCII));
            out.flush();

            // Read PONG response
            InputStream in = socket.getInputStream();
            byte[] buffer = new byte[64];
            int bytesRead = in.read(buffer);
            String response = new String(buffer, 0, bytesRead, StandardCharsets.US_ASCII);

            boolean available = response.trim().equals("PONG");
            log.debug("ClamAV availability check: {}", available ? "available" : "not available");
            return available;

        } catch (IOException e) {
            log.warn("ClamAV is not available: {}", e.getMessage());
            return false;
        }
    }

    public String getVersion() {
        try (Socket socket = createSocket()) {
            OutputStream out = socket.getOutputStream();
            out.write("zVERSION\0".getBytes(StandardCharsets.US_ASCII));
            out.flush();

            InputStream in = socket.getInputStream();
            byte[] buffer = new byte[256];
            int bytesRead = in.read(buffer);
            return new String(buffer, 0, bytesRead, StandardCharsets.US_ASCII).trim();

        } catch (IOException e) {
            log.warn("Failed to get ClamAV version: {}", e.getMessage());
            return "Unknown";
        }
    }
}
